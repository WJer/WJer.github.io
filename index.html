

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>WJer&#39;s time</title>
  <meta name="author" content="WJer">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="WJer&#39;s time"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="WJer&#39;s time" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffe3814b5f53cc394a493cbeb2368f2af' type='text/javascript'%3E%3C/script%3E"));
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-41207871-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</head>


<body>
  <header id="header" class="inner">
<div class="alignleft">
  <h1><a href="/">WJer&#39;s time</a></h1>
  <h2><a href="/">Windy,only try to survive</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
  
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-05T08:04:26.000Z"><a href="/2016/03/05/underscorejs-_的本质/">2016-03-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/05/underscorejs-_的本质/">underscorejs-_的本质</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="_是什么？">_是什么？</h2><p>附上源码：</p>
<pre><code><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>{
       <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;
        <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);
        <span class="keyword">this</span>._wrapped = obj;
  };
<span class="keyword">return</span> _;
</code></pre><p><code>_</code>实际上就是个方法，所有的方法都是<code>_</code>这个方法对象的属性（js中万物都是对象，包括方法本身也是个对象）。<br>例如：</p>
<pre><code>_.<span class="keyword">each</span>=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    ......
};
_.map=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    ......
};
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-05T04:30:30.000Z"><a href="/2016/03/05/算法-快速排序算法/">2016-03-05</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/05/算法-快速排序算法/">算法-快速排序算法</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="快速排序算法">快速排序算法</h2><p>排序算法的种类有很多，你可以使用数组自带的sort()来进行排序，复杂度也就呵呵了。<br>至今使用最多的要当属快速排序算法了，原理很简单，递归加二分：</p>
<p>第一步：选择一个元素作为基准，一般选中位数的元素。<br>第二步：小于基准的元素放到左边，小于右边的元素放到右边。和基准相等的元素左、右都可以。<br>解释：这样进行保证基准元素的大小始终处于中间的位置。<br>第三步：对左边和右边继续进行第一步和第二步，直到左边和右边只有一个元素或者为空。</p>
<p>上代码：</p>
<pre><code>function <span class="built_in">quickSort</span>(arr){
    <span class="keyword">var</span> <span class="keyword">left</span>=[],<span class="comment">//左边子集</span>
             <span class="keyword">right</span>=[];<span class="comment">//右边子集</span>
    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>){<span class="comment">//递归的出口</span>
        <span class="keyword">return</span> arr;
    }
    <span class="keyword">var</span> baseindex=<span class="type">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//执行第一步，找基准元素</span>
    <span class="keyword">var</span> pivot=arr.splice(baseindex,<span class="number">1</span>)[<span class="number">0</span>];
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++){
        <span class="comment">//执行第二步，分左右子集</span>
        <span class="keyword">if</span>(arr[i]&lt;pivot){
            <span class="keyword">left</span>.push(arr[i]);
        }<span class="keyword">else</span>{
            <span class="keyword">right</span>.push(arr[i]);
        }
    }
    <span class="keyword">return</span> <span class="built_in">quickSort</span>(<span class="keyword">left</span>).concat(pivot,<span class="built_in">quickSort</span>(<span class="keyword">right</span>));<span class="comment">//递归</span>
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-02T12:37:20.000Z"><a href="/2016/03/02/js-严格模式/">2016-03-02</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/02/js-严格模式/">js-严格模式</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="严格模式">严格模式</h2><ul>
<li><p>必须使用var声明变量</p>
<p>  i=0;//报错<br>  var i=0;//正确</p>
</li>
<li><p>允许静态绑定，限制动态绑定</p>
<p>  禁止使用with<br>  with(o){</p>
<pre><code>i=<span class="number">0</span>;<span class="comment">//报错</span>
</code></pre><p>  }//with是在运行时去寻找对象的</p>
</li>
</ul>
<pre><code>增设<span class="built_in">eval</span>作用域
严格模式下的三种作用域：全局作用域，函数作用域，<span class="built_in">eval</span>作用域
<span class="built_in">eval</span>(<span class="string">"var a=1;"</span>)//<span class="built_in">eval</span>作用域
</code></pre><ul>
<li><p>增设的安全措施</p>
<p>  禁止this指向全局对象</p>
<p>  使用构造函数时,不加new就会报错</p>
<p>  禁止在函数内部遍历<code>caller</code>和<code>arguments</code>等属性</p>
</li>
<li><p>不可以随意删除变量，除非configurable为true.</p>
</li>
<li><p>对某个对象只读的属性赋值报错；对禁止扩展的对象赋值报错；删除不可以删除的属性报错</p>
</li>
<li><p>对象属性不能重名，函数参数不能重名</p>
</li>
<li><p>不再追踪arguments的变化，传递是什么，argumens就是什么，不会再变化</p>
</li>
<li><p>无法使用arguments.callee调用自身</p>
</li>
<li><p>函数必须声明在顶层，其他位置以及代码块中都不可以</p>
</li>
<li><p>严格模式下新增了保留字</p>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-02T11:05:49.000Z"><a href="/2016/03/02/HTML5-web存储/">2016-03-02</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/02/HTML5-web存储/">HTML5-web存储</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="web存储">web存储</h2><p>web存储分为localStorage和sessionStorage<br>它们的本质是个持久化关联数组，什么意思呢？也就是个数组。数据是以键值对的形式保存在数组当中。<br>它是cookie的替代品。</p>
<h4 id="web存储的优势与不足">web存储的优势与不足</h4><p>优势：当今主流浏览器都支持；易于使用；支持大容量存储数据。<br>不足：IE8之前都浏览器不兼容</p>
<p>####　localStorage和sessionStorage　####<br>二者的区别要从<code>有效期</code>和<code>作用域</code>说起。<br>localStorage：只要你不删除，数据将永久保存；凡是同源的文档在同浏览器里都可以访问到localStorage。<br>sessionStorage：页面标签在，sessionStorage就在；同源的文档在同浏览器的同标签里可以访问到sessionStorage。（现在的浏览器可以打开最近的标签，这意味着sessionStorage可以多活一会）</p>
<h4 id="常用API">常用API</h4><ul>
<li>getItem(key)</li>
<li>setItem()</li>
<li>removeItem(key)</li>
<li>clear()</li>
<li>key(index)</li>
<li>length属性</li>
</ul>
<h4 id="存储事件">存储事件</h4><p>需要给<code>window</code>对象添加<code>storage事件</code>。<br>a页面和b页面同源，a页面改变了某个存储数据，b页面上就会触发storage事件，而a页面本身不会触发。也就是说浏览器都会在其他对该数据可见的窗口对象上触发存储事件。</p>
<p>适用场合：用户在该页面选择某个颜色作为背景颜色，这样可以通知其他同源文档知道这样的一个改变，进而修改背景颜色。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-29T09:12:24.000Z"><a href="/2016/02/29/js-事件-阻止默认阻止了什么？/">2016-02-29</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/29/js-事件-阻止默认阻止了什么？/">js-事件-阻止默认阻止了什么？</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>keypress事件</strong><br>当在回调函数执行e.preventDefault()时，会阻止字符显示到表单元素上。我们不管怎么按键，input或者textarea都不显示输入的字符。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-29T08:28:57.000Z"><a href="/2016/02/29/js-事件-文本事件/">2016-02-29</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/29/js-事件-文本事件/">js-文本事件</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="文本事件">文本事件</h2><h4 id="事件">事件</h4><p><strong> 第一系列：文本插入到元素前触发</strong><br>keypress事件：浏览器都支持<br>textInput事件：webkit内核支持<br>textinput事件：DOM3级事件，几乎不支持</p>
<p><strong> 第二系列：文本插入到元素后触发</strong><br>input事件：HTML5事件，除了IE都支持<br>propertychange事件：IE支持（间接检测）；此事件除了监听文本，还能监听多选框、单选框等<code>check属性</code></p>
<h4 id="keypress,textinput,textInput">keypress,textinput,textInput</h4><p><strong> keypress事件 </strong><br>事件对象有<code>keyCode属性(除火狐)</code>或者<code>charCode属性(火狐支持)</code>，该属性为输入字符对应的编码。<br>注意：区别于keydown事件和keyup事件，该事件<code>keyCode属性</code>返回的值为具体的字符对应的编码，而不是一个键对应的编码。例如：输入a会返回a的编码，输入大写A会返回大写A的编码。</p>
<p>通过<code>String.fromCharCode()</code>可以将编码转换为对应的具体字符。</p>
<p><strong> textinput事件,textInput事件 </strong><br>事件对象有<code>data属性</code>，保存输入的单个字符，仅能保存一个字符。<br>注意：保存的不是编码，而是字符。</p>
<p><strong> 示例 </strong></p>
<pre><code><span class="comment">/*
html标签用法：
&lt;input id="email" value="" type="text" data-messageid="emailwarn"     data-allowed-chars="0123456789"&gt;
&lt;span id="emailwarn" style="color: red;visibility:hidden; "&gt;1234&lt;/span&gt;
*/</span>
<span class="keyword">var</span> inputs=document.getElementsByTagName('<span class="keyword">input</span>');
<span class="keyword">for</span>(<span class="keyword">var</span> i=0;i&lt;inputs.length;i++){
    <span class="keyword">var</span> <span class="keyword">input</span>=inputs[i];
    <span class="keyword">if</span>(<span class="keyword">input</span>.<span class="keyword">type</span>!==<span class="string">"text"</span>||!<span class="keyword">input</span>.getAttribute('data-allowed-chars'))             <span class="keyword">continue</span>;
    <span class="comment">//添加事件</span>
    <span class="keyword">if</span>(<span class="keyword">input</span>.addEventListener){
        <span class="keyword">if</span>(<span class="keyword">input</span>.ontextinput){
            <span class="keyword">input</span>.addEventListener('textinput',handler,false);
        }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">input</span>.ontextInput){
            <span class="keyword">input</span>.addEventListener('textInput',handler,false);
        }<span class="keyword">else</span>{
            <span class="keyword">input</span>.addEventListener('keypress',handler,false);
        }
    }<span class="keyword">else</span>{
        <span class="keyword">input</span>.attachEvent(<span class="string">"keypress"</span>,handler);
    }
    function handler(event){

        <span class="keyword">var</span> <span class="keyword">e</span>=event||<span class="keyword">window</span>.event;
        <span class="keyword">var</span> target=<span class="keyword">e</span>.target||<span class="keyword">e</span>.srcElement;
        <span class="keyword">var</span> text=null;

        <span class="comment">//获取值</span>
        <span class="keyword">if</span>(<span class="keyword">e</span>.<span class="keyword">type</span>===<span class="string">"textinput"</span>||<span class="keyword">e</span>.<span class="keyword">type</span>===<span class="string">"textInput"</span>){
            text=<span class="keyword">e</span>.data;
        }<span class="keyword">else</span>{
            <span class="keyword">var</span> code=<span class="keyword">e</span>.charCode||<span class="keyword">e</span>.keyCode;<span class="comment">//ff使用charCode</span>
            <span class="keyword">if</span>(code&lt;32||
                <span class="keyword">e</span>.charCode==0||<span class="comment">//功能键（仅指火狐）</span>
                <span class="keyword">e</span>.ctrlKey||<span class="comment">//按下ctrl</span>
                <span class="keyword">e</span>.altKey){<span class="comment">//按下alt</span>
                <span class="keyword">return</span>;<span class="comment">//不过滤，直接退出方法</span>
            }
            <span class="keyword">var</span> text=String.fromCharCode(code);
        }
        <span class="keyword">var</span> allowed=target.getAttribute('data-allowed-chars');
        <span class="keyword">var</span> messageid=target.getAttribute('data-messageid');
        <span class="keyword">if</span>(messageid){
            <span class="keyword">var</span> msgele=document.getElementById(messageid);
        }
        <span class="keyword">if</span>(allowed.indexOf(text)==-1){
            msgele.style.visibility=<span class="string">"visible"</span>;
            <span class="keyword">e</span>.preventDefault();<span class="comment">//阻止字符输出在表单里</span>
        }<span class="keyword">else</span>{
            <span class="keyword">if</span>(msgele.style.visibility!=<span class="string">"hidden"</span>)
                msgele.style.visibility=<span class="string">"hidden"</span>;
        }
    }
}
</code></pre><p><strong>示例：</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">forceToUpperCase</span>(<span class="params">eleid</span>)</span>{
    <span class="keyword">if</span>(<span class="keyword">typeof</span> eleid!==<span class="string">"string"</span>){
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> input=<span class="built_in">document</span>.getElementById(eleid);
    input.oninput=upcase;
    input.onpropertychange=upcasePropertyChange;
    <span class="function"><span class="keyword">function</span> <span class="title">upcase</span>(<span class="params"></span>)</span>{
        <span class="keyword">this</span>.value=<span class="keyword">this</span>.value.toUpperCase();
    }
    <span class="function"><span class="keyword">function</span> <span class="title">upcasePropertyChange</span>(<span class="params">e</span>)</span>{
        <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;
        <span class="keyword">if</span>(e.propertyName===<span class="string">"value"</span>){

            <span class="comment">//注意这里</span>
            input.onpropertychange=<span class="literal">null</span>;<span class="comment">//避免循环</span>
            <span class="keyword">this</span>.value=<span class="keyword">this</span>.value.toUpperCase();
            input.onpropertychange=upcasePropertyChange;<span class="comment">//重新监听</span>
        }
    }
}

forceToUpperCase(<span class="string">'email'</span>);<span class="comment">//调用</span>
</code></pre><p>问题：当检测到value改变时，为嘛要取消监听，再重新监听。所谓的避免循环是什么意思？</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-29T06:20:07.000Z"><a href="/2016/02/29/underscorejs-数组方法之flatten源码分析/">2016-02-29</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/29/underscorejs-数组方法之flatten源码分析/">underscorejs-数组方法之flatten</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天，朋友给我讲面经时提到了一道题，js实现“多维数组压平”，看到这里的时候，我立马就想到了underscorejs中有这个方法，但那毕竟是别人的成果，自己会用但不知如何实现是硬生生的嚼别人的馒头，一点味都没有，于是我自己写了这个方法。</p>
<pre><code>function <span class="type">Util</span>(){}
<span class="type">Util</span>.flattern=function(arr,isrepeat){
    <span class="keyword">if</span>(!arr) <span class="keyword">return</span>;//没有数组，则退出
    <span class="keyword">var</span> <span class="literal">result</span>=[];//结果
    traverse(arr);
    //遍历的函数
    function traverse(arr){
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++){
            <span class="keyword">if</span>(<span class="type">Util</span>.isArray(arr[i])){
                traverse(arr[i]);
            }<span class="keyword">else</span>{
                <span class="literal">result</span>.push(arr[i]);
            }
        }
    }
    <span class="keyword">if</span>(isrepeat) <span class="literal">result</span>=<span class="type">Util</span>.norepeat(<span class="literal">result</span>);
    <span class="keyword">return</span> <span class="literal">result</span>;
}
<span class="type">Util</span>.isArray=function(arr){
    <span class="keyword">return</span> <span class="type">Object</span>.prototype.toString.call(arr).slice(<span class="number">8</span>,-<span class="number">1</span>)===<span class="string">"Array"</span>;
}
</code></pre><p>没错，基本原理就是递归。</p>
<p>ps:遍历数组的时候使用for循环，避免使用for-each循环。</p>
<p>下面我们再来看看underscorejs如何实现的。</p>
<pre><code><span class="keyword">var</span> flatten = function(input, shallow, strict, startIndex) {
    <span class="keyword">var</span> output = [], idx = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex || <span class="number">0</span>, length = getLength(input); i &lt; length; i++) {
        <span class="keyword">var</span> <span class="keyword">value</span> = input[i];<span class="comment">//取值</span>
        <span class="keyword">if</span> (isArrayLike(<span class="keyword">value</span>) &amp;&amp; (_.isArray(<span class="keyword">value</span>) || _.isArgument(<span class="keyword">value</span>))){<span class="comment">//考虑到三种情况</span>
            <span class="keyword">if</span> (!shallow) <span class="keyword">value</span> = flatten(<span class="keyword">value</span>, shallow, strict);<span class="comment">//开始递归</span>
            <span class="keyword">var</span> j = <span class="number">0</span>, len = <span class="keyword">value</span>.length;
            output.length += len;<span class="comment">//需要多少用多少</span>
            <span class="keyword">while</span> (j &lt; len) {
                output[idx++] = <span class="keyword">value</span>[j++];<span class="comment">//添加到输出的数组中</span>
            }
        } <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">!strict</span>) </span>{
            output[idx++] = <span class="keyword">value</span>;
        }
    }
    <span class="keyword">return</span> output;
};
</code></pre><p>大神考虑的真周全，<code>类似数组</code>和<code>arguments</code>都不放过。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-27T03:07:19.000Z"><a href="/2016/02/27/backbonejs-事件聚合器和中介者/">2016-02-27</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/27/backbonejs-事件聚合器和中介者/">backbonejs-事件聚合器和中介者</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天写完了这篇，但是哔了狗了，误删了，写的那么认真啊，成果为０。<br>算了，吃次亏，再温习一边吧。</p>
<h2 id="事件聚合器和中介者">事件聚合器和中介者</h2><h4 id="语义">语义</h4><p>了解语义，将有助于你了解事件聚合器和中介者。<br>假设一个情景：水果店的老板和苹果公司员工聊天，聊得内容是关于“苹果”，结果可想而知，水果店老板眼中的“苹果”是吃的水果，而员工眼中的“苹果”是用的电子产品，他们理解的事物并不是同一件事，所以话题并不能持续下去。</p>
<p>语义说白了，就是不同的词语在不同的环境下有着不同的含义。</p>
<h4 id="事件聚合器">事件聚合器</h4><p>附上事件聚合器代码：</p>
<pre><code><span class="keyword">var</span> View1=Backbone.View.extend({
    el:<span class="string">'body'</span>,
    events:{
        <span class="string">'click #container'</span>:<span class="string">'dosomething'</span>
    },
    initialize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        Backbone.on(<span class="string">'something'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">'我是view1'</span>);
        },<span class="keyword">this</span>);
    },
    dosomething:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="comment">// console.log('我是view1');</span>
        Backbone.trigger(<span class="string">'something'</span>);
    }    
    });
    <span class="keyword">var</span> View2=Backbone.View.extend({
        initialize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        Backbone.on(<span class="string">'something'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">'我是view2'</span>);
        },<span class="keyword">this</span>);
    }    
});
</code></pre><p>事件聚合器是内置在<code>Backbone</code>对象上的，通过<code>Backbone.on()</code>来创建事件聚合器，通过<code>Backbone.trigger()</code>来触发事件的。</p>
<p>ps:dom事件创建的方法是通过键盘或鼠标或滚轮作用在某个dom元素上，从而触发事件，但是这个事件触发器里事件作用在什么上面呢？这种事件区别于dom事件，这个事件的触发仅仅通过触发函数<code>Backbone.trigger()</code>来触发。</p>
<h4 id="中介者">中介者</h4><p>以考试为例：学生拿到卷子答卷–&gt;老师收卷，学生交卷–&gt;老师批卷–&gt;打分<br>附上中介者代码：</p>
<pre><code><span class="keyword">var</span> mediator={
    test:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">var</span> doTestStudent=getTestpaper();<span class="comment">//学生得到卷子</span>
        doTestStudent.on(<span class="string">"completeTest"</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="comment">//答卷完成时</span>
            <span class="keyword">var</span> doCheckTeacher=getCheckpaper();<span class="comment">//老师收卷</span>
            doCheckTeacher.on(<span class="string">"completeCheck"</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{<span class="comment">//批卷完成时</span>
                mark();<span class="comment">//打分</span>
            });
        });
    }
}
</code></pre><p><code>mediator</code>从js的角度来看只是个字面量兑现，但是从模式来看，它是个中介者，在这个中介者的内部是考试的流程。</p>
<h4 id="共性">共性</h4><p><strong>都涉及事件：</strong><br>事件聚合器，听名字就知道，跟事件有密切的联系。<br>中介者，因为内部装的是某个行为的流程，先干什么再干什么，使用事件通知的方式可以很方便实现流程。</p>
<h4 id="什么时候用">什么时候用</h4><p><strong>事件聚合器</strong><br>如果有很多很多的对象需要监听同一个事件，可以交给事件聚合器，需要触发的时候触发。事件的开销会降低。<br>示例:</p>
<pre><code><span class="comment">//低效的用法</span>
<span class="comment">//没有遇到经典的示例，日后补上</span>
</code></pre><p>如果没有关系的对象之间需要通知，可以使用事件聚合器来通知消息。可以降低耦合。<br>示例：</p>
<pre><code><span class="keyword">var</span> View1=Backbone.View.extend({
    events:{
        <span class="string">'click #container'</span>:<span class="string">'dosomething'</span>
    },
    initialize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{

    },
    dosomething:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        Backbone.trigger(<span class="string">'something'</span>);
    }    
});
<span class="keyword">var</span> View2=Backbone.View.extend({
    initialize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        Backbone.on(<span class="string">'something'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">'我是view2'</span>);
        },<span class="keyword">this</span>);
    }    
});
<span class="keyword">var</span> view1=<span class="keyword">new</span> View1();
<span class="keyword">var</span> view2=<span class="keyword">new</span> View2();

<span class="comment">//当view1视图里的某个元素发生点击时，将会通知view2里的操作</span>
</code></pre><p><strong>中介者</strong><br>如果两个以上的对象有间接的工作关系，我们可以使用中介者，将工作流程写在中介者内。<br>这样一来，对象间的工作关系将仅仅限制在中介者内，同时不需要考虑对象的细节，便于维护。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-26T03:24:46.000Z"><a href="/2016/02/26/jquery-on()/">2016-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/26/jquery-on()/">jquery-on()</a></h1>
  

    </header>
    <div class="entry">
      
        <p>过去我使用jquery添加方法时，确实如官方推荐，使用on()代替bind()，殊不知，on()方法的用法有很多种，现在来补补过去遗漏的用法。</p>
<h4 id="一个元素一个事件一个函数">一个元素一个事件一个函数</h4><pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="多个元素一个事件一个函数">多个元素一个事件一个函数</h4><pre><code>$(<span class="string">'#ele1,#ele2'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><p>####　一个元素多个事件一个函数 ####</p>
<pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'mouseover mouseout'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="一个元素多个事件多个函数">一个元素多个事件多个函数</h4><pre><code>$(<span class="string">'#ele'</span>).on({
    click:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        ......
    },
    mouseover:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        ......
    }
});
</code></pre><h4 id="自定义事件">自定义事件</h4><pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="给子元素添加事件">给子元素添加事件</h4><pre><code>$(<span class="string">'#parent'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="string">'#sub'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>    
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-26T03:09:39.000Z"><a href="/2016/02/26/backbonejs-view-setElement()源码分析/">2016-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/26/backbonejs-view-setElement()源码分析/">backbonejs-view-setElement源码分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>源码：</p>
<pre><code>setElement: <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>{
    <span class="keyword">this</span>.undelegateEvents();<span class="comment">//移除所有事件</span>
    <span class="keyword">this</span>._setElement(element);<span class="comment">//重新设置视图管理的标签</span>
    <span class="keyword">this</span>.delegateEvents();<span class="comment">//绑定所有事件</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回视图对象</span>
},

<span class="comment">//重新设置视图管理的标签：$el和el</span>
_setElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>{
    <span class="keyword">this</span>.$el = el <span class="keyword">instanceof</span> Backbone.$ ? el : Backbone.$(el);<span class="comment">//如果标签已经包装成backbone.$样子，那么直接赋值；否则进行包装再赋值</span>
    <span class="keyword">this</span>.el = <span class="keyword">this</span>.$el[<span class="number">0</span>];
},

<span class="comment">//委托所有事件</span>
delegateEvents: <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>{
    <span class="keyword">if</span> (!(events || (events = _.result(<span class="keyword">this</span>, <span class="string">'events'</span>)))) <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//如果没有参数也没有events属性，则退出方法</span>
    <span class="keyword">this</span>.undelegateEvents();<span class="comment">//移除所有事件</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> events) {
        <span class="keyword">var</span> method = events[key];
        <span class="keyword">if</span> (!_.isFunction(method)) method = <span class="keyword">this</span>[events[key]];
        <span class="keyword">if</span> (!method) <span class="keyword">continue</span>;
        <span class="comment">//例如："click #sub1":"add",该步骤将key值拆分成click和#sub1</span>
        <span class="keyword">var</span> match = key.match(delegateEventSplitter);
        <span class="keyword">this</span>.delegate(match[<span class="number">1</span>], match[<span class="number">2</span>], _.bind(method, <span class="keyword">this</span>));<span class="comment">//绑定事件</span>
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},

<span class="comment">//取消所有委托事件</span>
undelegateEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) <span class="keyword">this</span>.$el.off(<span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid);<span class="comment">//通过部分字段移除事件</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},

<span class="comment">//绑定单个事件，事件名为自定义的，可以给子元素绑定</span>
delegate: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, selector, listener</span>) </span>{
    <span class="keyword">this</span>.$el.on(eventName + <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid, selector,listener);
},

<span class="comment">//移除单个指定事件</span>
undelegate: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, selector, listener</span>) </span>{
    <span class="keyword">this</span>.$el.off(eventName + <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid, selector, listener);
},
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一頁</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分類</h3>
  <ul class="entry">
  
    <li><a href="/categories/HTML5/">HTML5</a><small>2</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>2</small></li>
  
    <li><a href="/categories/backbonejs/">backbonejs</a><small>4</small></li>
  
    <li><a href="/categories/bootstrap/">bootstrap</a><small>1</small></li>
  
    <li><a href="/categories/css/">css</a><small>3</small></li>
  
    <li><a href="/categories/hexo/">hexo</a><small>2</small></li>
  
    <li><a href="/categories/jquery/">jquery</a><small>1</small></li>
  
    <li><a href="/categories/js/">js</a><small>20</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>3</small></li>
  
    <li><a href="/categories/node-js/">node.js</a><small>2</small></li>
  
    <li><a href="/categories/underscorejs/">underscorejs</a><small>2</small></li>
  
    <li><a href="/categories/推荐/">推荐</a><small>1</small></li>
  
    <li><a href="/categories/插件/">插件</a><small>1</small></li>
  
    <li><a href="/categories/浏览器/">浏览器</a><small>2</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>1</small></li>
  
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">个人介绍</h3>
<ul class="entry">

<li><img src="/imgs/jinmu.jpg" style="width:100%"/></li>
<li>博主：吴敬</li>
<li>星座：双鱼座</li>
<li>现状：合肥工业大学本科生</li>
<li>想要约我的<a href="×××" title="QQ:1025620771">联系我</a>！</li>
<!--
<li><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=230 height=86 src="http://music.163.com/outchain/player?type=2&id=39443443&auto=1&height=66"></iframe></li>
-->
</ul>
</div>



  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src=""></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 WJer
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>



