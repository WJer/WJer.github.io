

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>WJer&#39;s time</title>
  <meta name="author" content="WJer">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="WJer&#39;s time"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="WJer&#39;s time" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffe3814b5f53cc394a493cbeb2368f2af' type='text/javascript'%3E%3C/script%3E"));
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-41207871-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</head>


<body>
  <header id="header" class="inner">
<div class="alignleft">
  <h1><a href="/">WJer&#39;s time</a></h1>
  <h2><a href="/">Windy,only try to survive</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
  
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-26T03:24:46.000Z"><a href="/2016/02/26/jquery-on()/">2016-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/26/jquery-on()/">jquery-on()</a></h1>
  

    </header>
    <div class="entry">
      
        <p>过去我使用jquery添加方法时，确实如官方推荐，使用on()代替bind()，殊不知，on()方法的用法有很多种，现在来补补过去遗漏的用法。</p>
<h4 id="一个元素一个事件一个函数">一个元素一个事件一个函数</h4><pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="多个元素一个事件一个函数">多个元素一个事件一个函数</h4><pre><code>$(<span class="string">'#ele1,#ele2'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><p>####　一个元素多个事件一个函数 ####</p>
<pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'mouseover mouseout'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="一个元素多个事件多个函数">一个元素多个事件多个函数</h4><pre><code>$(<span class="string">'#ele'</span>).on({
    click:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        ......
    },
    mouseover:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        ......
    }
});
</code></pre><h4 id="自定义事件">自定义事件</h4><pre><code>$(<span class="string">'#ele'</span>).<span class="keyword">on</span>(<span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>
</code></pre><h4 id="给子元素添加事件">给子元素添加事件</h4><pre><code>$(<span class="string">'#parent'</span>).<span class="keyword">on</span>(<span class="string">'click'</span>,<span class="string">'#sub'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">{
    ......
}</span>);</span>    
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-26T03:09:39.000Z"><a href="/2016/02/26/backbonejs-view-setElement()源码分析/">2016-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/26/backbonejs-view-setElement()源码分析/">backbonejs-view-setElement源码分析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>源码：</p>
<pre><code>setElement: <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>{
    <span class="keyword">this</span>.undelegateEvents();<span class="comment">//移除所有事件</span>
    <span class="keyword">this</span>._setElement(element);<span class="comment">//重新设置视图管理的标签</span>
    <span class="keyword">this</span>.delegateEvents();<span class="comment">//绑定所有事件</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回视图对象</span>
},

<span class="comment">//重新设置视图管理的标签：$el和el</span>
_setElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>{
    <span class="keyword">this</span>.$el = el <span class="keyword">instanceof</span> Backbone.$ ? el : Backbone.$(el);<span class="comment">//如果标签已经包装成backbone.$样子，那么直接赋值；否则进行包装再赋值</span>
    <span class="keyword">this</span>.el = <span class="keyword">this</span>.$el[<span class="number">0</span>];
},

<span class="comment">//委托所有事件</span>
delegateEvents: <span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>{
    <span class="keyword">if</span> (!(events || (events = _.result(<span class="keyword">this</span>, <span class="string">'events'</span>)))) <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//如果没有参数也没有events属性，则退出方法</span>
    <span class="keyword">this</span>.undelegateEvents();<span class="comment">//移除所有事件</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> events) {
        <span class="keyword">var</span> method = events[key];
        <span class="keyword">if</span> (!_.isFunction(method)) method = <span class="keyword">this</span>[events[key]];
        <span class="keyword">if</span> (!method) <span class="keyword">continue</span>;
        <span class="comment">//例如："click #sub1":"add",该步骤将key值拆分成click和#sub1</span>
        <span class="keyword">var</span> match = key.match(delegateEventSplitter);
        <span class="keyword">this</span>.delegate(match[<span class="number">1</span>], match[<span class="number">2</span>], _.bind(method, <span class="keyword">this</span>));<span class="comment">//绑定事件</span>
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},

<span class="comment">//取消所有委托事件</span>
undelegateEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) <span class="keyword">this</span>.$el.off(<span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid);<span class="comment">//通过部分字段移除事件</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},

<span class="comment">//绑定单个事件，事件名为自定义的，可以给子元素绑定</span>
delegate: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, selector, listener</span>) </span>{
    <span class="keyword">this</span>.$el.on(eventName + <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid, selector,listener);
},

<span class="comment">//移除单个指定事件</span>
undelegate: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, selector, listener</span>) </span>{
    <span class="keyword">this</span>.$el.off(eventName + <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid, selector, listener);
},
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-25T04:02:05.000Z"><a href="/2016/02/25/css-wordwrap和worldbreak/">2016-02-25</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/25/css-wordwrap和worldbreak/">css-wordwrap和worldbreak</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="word-wrap和word-break">word-wrap和word-break</h2><p>都是css3属性</p>
<h4 id="word-wrap属性">word-wrap属性</h4><p>是否可以在单词内断句</p>
<p>如果某个单词特别特别长，长的超过了所在容器的宽度。默认情况下，这个单词会显示在同一行，当然单词超过了容器的边界，样子很丑陋。</p>
<p>设置了<code>word-wrap:break-word</code>,允许在单词内部断开。单词会分两行或者多行显示，不管怎么样都会现实在容器内部而不会超过边界。</p>
<h4 id="word-break属性">word-break属性</h4><p>怎么样进行换行</p>
<p>默认情况下，对于一段英语段落，换行的位置总是在空格或者标点符号或者连字符出。</p>
<p>设置了<code>word-break:break-all</code>,换行的位置可以出现在段落的任何位置，不再受到限制。</p>
<p>我们发现，<code>不受位置限制的换行</code>可能会发生<code>单词内部断句</code>。<br>总之它的好处是可以节约容器内的空间，不会出现太多的空白。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-25T01:37:01.000Z"><a href="/2016/02/25/js-事件-键盘事件/">2016-02-25</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/25/js-事件-键盘事件/">js-键盘事件</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="键盘事件">键盘事件</h2><h4 id="键盘上有哪些键">键盘上有哪些键</h4><p>辅助键：ctrl,alt,shift,windows,fn<br>功能键：f1~f12<br>字母数字键</p>
<h4 id="键盘事件-1">键盘事件</h4><p>keydown事件<br>keyup事件<br>keypress事件</p>
<h4 id="键盘事件的发展过程">键盘事件的发展过程</h4><p><strong>关于keydown和keyup</strong><br>DOM3级以前，keydown事件和keyup事件以及keyCode属性从未标准化；<br>3级DOM事件才标准化了keydown事件和keyup事件,但未标准化keyCode属性，同时提出了新的<code>key属性</code>。</p>
<h4 id="键盘事件对象的属性">键盘事件对象的属性</h4><p><code>altKey</code>，<code>ctrlKey</code>，<code>shiftKey</code>属性，值为true or false<br><code>keyCode</code>属性，值为键对应的unicode编码。<br><code>key</code>属性，值为键对应的名字（支持的浏览器不多）<br><code>keyIdentifier</code>属性，值为键对应的unicode编码的字符串形式（webkit内核支持）</p>
<h4 id="keyCode属性弊端">keyCode属性弊端</h4><p><strong>发生keydown和keyup事件</strong><br>对于字母键，输入字母时，keyCode属性总是返回大写字母的unicode编码；<br>对于带标点的数字键，输入标点时，keyCode属性返回数字的unicode编码；</p>
<p><strong>发生keypress事件</strong><br>以上情况不会发生，输入大写字母和小写字母时，keyCode属性值是各自对应的unicode编码。</p>
<h4 id="案例：键盘快捷键类">案例：键盘快捷键类</h4><p>功能：</p>
<ul>
<li>点击某个键，会出想对应的行为</li>
<li>监听某个发生键盘事件的元素</li>
<li>将键的unicode转化为对应的键的名称</li>
</ul>
<p><a href="https://github.com/WJer/keymap" target="_blank" rel="external">键盘类的链接</a> </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-24T13:22:59.000Z"><a href="/2016/02/24/backbonejs-常用解决方案/">2016-02-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/24/backbonejs-常用解决方案/">backbonejs-常用解决方案</a></h1>
  

    </header>
    <div class="entry">
      
        
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-24T11:30:17.000Z"><a href="/2016/02/24/backbonejs-restful持久化/">2016-02-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/24/backbonejs-restful持久化/">backbonejs-restful持久化</a></h1>
  

    </header>
    <div class="entry">
      
        <p>##　Restful持久化 ##<br>对于后端的MVC来说，服务器上的数据要和数据库上的数据同步，但是对于前端而言，客户端的数据要和服务器上的数据保持一致。</p>
<p>backbone.js就提供了一系列简单的API，用于数据的同步。</p>
<h4 id="整个集合中数据的获取">整个集合中数据的获取</h4><pre><code><span class="built_in">var</span> M=Backbone<span class="built_in">.</span>Model<span class="built_in">.</span>extend({
    defaults:{
        <span class="attribute">...</span><span class="attribute">...</span>
    }
});
<span class="built_in">var</span> C=Backbone<span class="built_in">.</span>Collection<span class="built_in">.</span>extend({
    model:M,
    url:<span class="string">'**/**/**'</span>
});
<span class="built_in">var</span> collection=<span class="literal">new</span> C();

collection<span class="built_in">.</span>fetch();<span class="comment">//关键步骤,从服务器上获取</span>
</code></pre><h4 id="单个数据模型保存">单个数据模型保存</h4><pre><code><span class="keyword">var</span> <span class="keyword">M</span>=Backbone.Model.extend({
    defaults:{
        ......
    }
});
<span class="keyword">var</span> C=Backbone.Collection.extend({
    model:<span class="keyword">M</span>,
    url:'**<span class="comment">/**/</span>**'
});
<span class="keyword">var</span> collection=new C();
collection.fetch();
<span class="keyword">var</span> model=collection.<span class="literal">get</span>(id);
model.<span class="keyword">set</span>({key1:value1,key2:value2,key3:value3});

model.<span class="keyword">save</span>();<span class="comment">//关键步骤,保存到服务器上</span>
</code></pre><h4 id="单个数据模型的删除">单个数据模型的删除</h4><pre><code><span class="built_in">var</span> M=Backbone<span class="built_in">.</span>Model<span class="built_in">.</span>extend({
    defaults:{
        <span class="attribute">...</span><span class="attribute">...</span>
    }
});
<span class="built_in">var</span> C=Backbone<span class="built_in">.</span>Collection<span class="built_in">.</span>extend({
    model:M,
    url:<span class="string">'**/**/**'</span>
});
<span class="built_in">var</span> collection=<span class="literal">new</span> C();
collection<span class="built_in">.</span>fetch();
<span class="built_in">var</span> model=collection<span class="built_in">.</span>get(id);

model<span class="built_in">.</span>destroy();<span class="comment">//关键步骤，从服务器上删除</span>
</code></pre><h4 id="当个数据模型局部更新">当个数据模型局部更新</h4><pre><code><span class="built_in">var</span> M=Backbone<span class="built_in">.</span>Model<span class="built_in">.</span>extend({
    defaults:{
        <span class="attribute">...</span><span class="attribute">...</span>
    }
});
<span class="built_in">var</span> C=Backbone<span class="built_in">.</span>Collection<span class="built_in">.</span>extend({
    model:M,
    url:<span class="string">'**/**/**'</span>
});
<span class="built_in">var</span> collection=<span class="literal">new</span> C();
collection<span class="built_in">.</span>fetch();
<span class="built_in">var</span> model=collection<span class="built_in">.</span>get(id);

model<span class="built_in">.</span>save({key1:value1,key2:value2},{patch:<span class="literal">true</span>});<span class="comment">//关键步骤。局部更新的内容＋局部更新的参数</span>
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-24T02:58:12.000Z"><a href="/2016/02/24/css-媒体查询/">2016-02-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/24/css-媒体查询/">css-媒体查询</a></h1>
  

    </header>
    <div class="entry">
      
        <p>媒体查询（Media Queries）<br>媒体查询＝设备类型＋设备特性＋样式</p>
<p>格式如下：</p>
<pre><code>＠media 媒体类型 <span class="keyword">and</span> (设备特性:值) <span class="keyword">and</span> (设备特性:值){
    css样式
}
</code></pre><p>设备类型：<br>    all/screen/print/handheld/tv/speech/braille等等</p>
<p>设备特性<br>    width/height/device-width/device-height/orientation/color等等</p>
<p>only关键字<br>    如果浏览器不支持媒体查询但识别设备类型怎么办？<br>    only关键字可以告诉这些浏览器浏览器忽略掉媒体查询中的样式，具体行为如下：</p>
<ul>
<li>浏览器支持媒体查询：采用样式</li>
<li>不支持媒体查询但识别设备类型：读到only，就忽略掉样式</li>
<li>不设备查询不能读取设备类型：有无only，都忽略样式</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-24T02:11:16.000Z"><a href="/2016/02/24/js-ajax之XHR对象/">2016-02-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/24/js-ajax之XHR对象/">js-ajax之XHR对象</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="XMLHttpRequest对象">XMLHttpRequest对象</h2><h2 id="基础">基础</h2><p>属性：</p>
<pre><code>readyState属性
<span class="number">0</span>:XMLHttpRequest对象未初始化
<span class="number">1</span>:open方法成功调用
<span class="number">2</span>:send方法成功调用
<span class="number">3</span>:正在接受数据，但未未完成
<span class="number">4</span>:已经完成

onreadystatechange属性
readyState改变触发的事件

responseText属性
responseXML属性
返回的xml或者text内容

status属性
服务器返回的http状态码

statusText属性
服务器返回的状态文本
</code></pre><p>方法：</p>
<pre><code>open<span class="list">(<span class="keyword">post/get</span>,url,sync,username,password)</span><span class="comment">;</span>

send<span class="list">(<span class="keyword">content</span>)</span><span class="comment">;</span>

setRequestHeader<span class="list">(<span class="keyword">key</span>,value)</span><span class="comment">;</span>

getResponseHeader<span class="list">(<span class="keyword">key</span>)</span><span class="comment">;</span>

abort<span class="list">()</span><span class="comment">;</span>
</code></pre><h2 id="如何使用">如何使用</h2><p>第一步：创建对象</p>
<pre><code><span class="keyword">var</span> xmlhttprequest;
<span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest){  
           xmlhttprequest=<span class="keyword">new</span> XMLHttpRequest();  
           <span class="keyword">if</span>(xmlhttprequest.overrideMimeType){  
               xmlhttprequest.overrideMimeType(<span class="string">"text/xml"</span>);  
           }  
   }<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject){  
          <span class="keyword">var</span> activeName=[<span class="string">"MSXML2.XMLHTTP"</span>,<span class="string">"Microsoft.XMLHTTP"</span>];  
           <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;activeName.length;i++){  
               <span class="keyword">try</span>{  
                      xmlhttprequest=<span class="keyword">new</span> ActiveXObject(activeName[i]);  
                       <span class="keyword">break</span>;  
               }<span class="keyword">catch</span>(e){  

               }  
           }  
   }  

   <span class="keyword">if</span>(xmlhttprequest==<span class="literal">undefined</span> || xmlhttprequest==<span class="literal">null</span>){  
           alert(<span class="string">"XMLHttpRequest对象创建失败！！"</span>);  
   }<span class="keyword">else</span>{  
           <span class="keyword">this</span>.xmlhttp=xmlhttprequest;  
   }
</code></pre><p>第二步：回调方法</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">()</span></span>{  
    <span class="keyword">if</span>（xmlhttp.readState==<span class="number">4</span>）{  
         <span class="comment">//表示服务器的相应代码是200；正确返回了数据   </span>
            <span class="keyword">if</span>(xmlhttp.status==<span class="number">200</span>){   
                <span class="comment">//纯文本数据的接受方法   </span>
                    <span class="keyword">var</span> message=xmlhttp.responseText;   
                    <span class="comment">//使用的前提是，服务器端需要设置content-type为text/xml   </span>
                    <span class="comment">//var domXml=xmlhttp.responseXML;   </span>
                    <span class="comment">//其它代码  </span>
             }   
        }  
 }
</code></pre><p>第三步：注册回调方法</p>
<pre><code>xmlhttprequest.onreadystatechange=callback<span class="comment">;</span>
</code></pre><p>第四步：设置请求参数</p>
<pre><code>xmlhttprequest.<span class="keyword">open</span>('<span class="keyword">get</span>',url,<span class="literal">true</span>);
</code></pre><p>第五步：发送请求</p>
<pre><code>xmlhttprequest.<span class="built_in">send</span>(<span class="literal">null</span> <span class="literal">or</span> content)<span class="comment">;</span>
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-23T07:43:42.000Z"><a href="/2016/02/23/HTML5-webworker见解/">2016-02-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/23/HTML5-webworker见解/">HTML5-webworker见解</a></h1>
  

    </header>
    <div class="entry">
      
        <p>多线程是个很高效的事情，HTML5也增加了关于线程的新API。</p>
<h4 id="如何使用">如何使用</h4><p>script.js</p>
<pre><code>onmessage=<span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>{
    var <span class="type">data</span>=event.<span class="type">data</span>;
    postmessage(<span class="type">data</span>);
}
</code></pre><p>index.html</p>
<pre><code><span class="comment">&lt;!--js部分--&gt;</span>
var worker=new WebWorker('script.js');
worker.onmessage=function(event){
    alert(event.data);
}
worker.postmessage("hello world");
</code></pre><h4 id="哪种场合可以使用">哪种场合可以使用</h4><p><strong>提高渲染速度</strong><br>我们都知道浏览器在执行js时是不渲染页面的，如果我们要使用js处理一大堆数据，势必会浪费时间，这时我们可以交给线程来做，最后再将处理的结果返回给浏览器。<br>这样渲染和执行js同时进行，大大提高了页面的加载速度。<br><strong>ajax请求</strong><br>线程中是可以进行ajax请求的，</p>
<h4 id="能力有限">能力有限</h4><p>线程中是无法访问window、document对象的，意味着不能进行DOM操作。<br>不是所有的浏览器都支持该API</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-02-23T06:16:43.000Z"><a href="/2016/02/23/css-影响/">2016-02-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/02/23/css-影响/">css-影响</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="影响一">影响一</h4><p><code>float:left/right</code>的设定会导致<code>块级元素</code>显示<code>内联元素</code>的特征,就是说不再充满整个一行，宽度由内容来决定。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一頁</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分類</h3>
  <ul class="entry">
  
    <li><a href="/categories/HTML5/">HTML5</a><small>1</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>2</small></li>
  
    <li><a href="/categories/backbonejs/">backbonejs</a><small>3</small></li>
  
    <li><a href="/categories/bootstrap/">bootstrap</a><small>1</small></li>
  
    <li><a href="/categories/css/">css</a><small>3</small></li>
  
    <li><a href="/categories/hexo/">hexo</a><small>2</small></li>
  
    <li><a href="/categories/jquery/">jquery</a><small>1</small></li>
  
    <li><a href="/categories/js/">js</a><small>18</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>3</small></li>
  
    <li><a href="/categories/node-js/">node.js</a><small>2</small></li>
  
    <li><a href="/categories/推荐/">推荐</a><small>1</small></li>
  
    <li><a href="/categories/插件/">插件</a><small>1</small></li>
  
    <li><a href="/categories/浏览器/">浏览器</a><small>2</small></li>
  
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">个人介绍</h3>
<ul class="entry">

<li><img src="/imgs/jinmu.jpg" style="width:100%"/></li>
<li>博主：吴敬</li>
<li>星座：双鱼座</li>
<li>现状：合肥工业大学本科生</li>
<li>想要约我的<a href="×××" title="QQ:1025620771">联系我</a>！</li>
<!--
<li><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=230 height=86 src="http://music.163.com/outchain/player?type=2&id=39443443&auto=1&height=66"></iframe></li>
-->
</ul>
</div>



  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src=""></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 WJer
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>



